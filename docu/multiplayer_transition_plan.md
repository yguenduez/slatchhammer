# Slatchhammer – Multiplayer Transition Plan (generated by o3)

A concise, step-by-step checklist for turning the current local-only Bevy prototype  
into an online 1 v 1 game with any number of parallel lobbies.

---

## 1. Choose a browser-friendly transport

| Option          | Works in all browsers | Unreliable (UDP-like) | Crate             |
|-----------------|----------------------|-----------------------|-------------------|
| WebSocket       | ✅                   | ❌                    | `bevy_renet`      |
| WebTransport    | ⚠ (Safari behind flag)| ✅ / ✅ ordered      | `bevy_renet` + `renet_webtransport` |

For "works everywhere now", select **WebSocket via `bevy_renet`**.

---

## 2. Restructure the repository

```
slatchhammer/
 ├─ common/   # shared data (components, messages, constants)
 ├─ client/   # wasm & native renderer
 └─ server/   # headless authoritative simulation
```

### `common`

* `bevy` (no default features) – pure ECS
* `serde`, `bincode` – serialisation

Exports only **data**:

```rust
pub struct PlayerInput { up: bool, down: bool, left: bool, right: bool, sprint: bool }
pub enum ClientMsg { Input { tick, input }, Ready }
pub enum ServerMsg { Snapshot { tick, bytes }, LobbyInfo { players }, StartMatch { your_entity } }
pub struct NetEntity(pub u64);
pub const TICK_RATE: f32 = 60.0;
```

---

## 3. Authoritative server

1. Bevy app with `WindowPlugin::disabled()`.
2. Add `bevy_rapier3d` and all existing gameplay plugins (`ArenaPlugin`, `GameStatePlugin`, …).
3. Add `RenetServerPlugin`.
4. Loop each **tick** (60 Hz):
   1. Read all `ClientMsg::Input`.
   2. Apply to entities (`ControlledBy(ClientId)`).
   3. Run physics step.
   4. Pack world state → `ServerMsg::Snapshot`.
   5. Broadcast to lobby players.

### Lobbies

```rust
struct Lobby { players: [Option<ClientId>; 2], state: LobbyState }
enum LobbyState { Waiting, Running { tick: Tick } }
```

* Put new connections into the first lobby with a free slot (or spawn a new one).
* When lobby holds 2 players **and** both sent `Ready`, spawn ball/players, send `StartMatch`.

---

## 4. Thin client

1. Compile to **WASM** for browsers, native for debugging.
2. Add `RenetClientPlugin`.
3. Keyboard → `PlayerInput` → send each frame (`CHANNEL_INPUT`, unreliable).
4. Receive `ServerMsg::Snapshot`, write to a "net replica world".
5. Interpolate replica → visible world every render frame.
6. (Optional) client-side prediction + rewind for smoother feel.

---

## 5. Port the existing keyboard code

* Delete the local `Player1`/`Player2` movement system from shared code.
* Client gathers keys:

```rust
fn gather_input(keys: Res<Input<KeyCode>>, mut net: ResMut<RenetClient>, tick: Res<CurrentTick>) {
    let input = PlayerInput {
        up:    keys.pressed(KeyCode::W),
        down:  keys.pressed(KeyCode::S),
        left:  keys.pressed(KeyCode::A),
        right: keys.pressed(KeyCode::D),
        sprint: keys.pressed(KeyCode::ShiftLeft),
    };
    net.send_unnamed_message(
        CHANNEL_INPUT,
        bincode::serialize(&ClientMsg::Input { tick: tick.0, input }).unwrap(),
    );
}
```

(Other player presses his own keys on his own machine.)

---

## 6. Build & deploy

### Client (WebAssembly)

```sh
rustup target add wasm32-unknown-unknown
cargo build --release --target wasm32-unknown-unknown -p client
wasm-bindgen --target web --out-dir out target/wasm32-unknown-unknown/release/client.wasm
```

Host the `out/` folder (Vercel, Netlify, …).

### Server

```sh
cargo build --release -p server
scp target/release/server  user@vps:/opt/slatchhammer/
```

Run behind a reverse-proxy that upgrades to WebSocket / WebTransport.

---

## 7. Incremental roadmap

1. Create `common` crate with messages.
2. Keep game playable offline: wrap old keyboard system behind a feature flag.
3. Add `RenetClient` → echo test.
4. Extract headless server, copy gameplay plugins.
5. Implement authoritative flow (inputs → snapshot).
6. Add lobby resource.
7. Client interpolation.
8. Polish, secure, and launch.

---

### Notes

* Keep snapshots small → `bincode` + `lz4` or `zstd` if needed.
* Determinism: use identical Rapier version & feature set on client/server.
* Server validates inputs (no teleport, sprint cooldown …).
* Lobbies scale linearly; spawn one `World` per lobby or tag entities with `LobbyId`.

Happy networking!